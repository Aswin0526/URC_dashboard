{% extends 'index.html' %} {% block content %}
<style>
  /* Overall container styling */
  .container {
    display: flex;
    width: 100%;
    height: 90vh;
    background: #f0f0f0;
    position: relative;
    top: 2%;
    box-sizing: border-box;
    padding: 10px;
  }

  .camera-section {
    display: flex;
    flex-direction: row;
    width: 70%;
    gap: 2px;
  }

  .go-pro {
    width: 30%;
    height: 100%;
    background-color: #000; /* Ensure background is black */
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .camera-feeds {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    gap: 2px;
  }

  .zed {
    width: 100%;
    height: 40%;
    background: #000; /* Fallback background */
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cameras {
    width: 100%;
    height: 60%;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #000;
    gap: 5px;
  }

  .cam1 {
    width: 50%;
    height: 100%;
    background: #000; /* Fallback background */
    display: flex;
  }

  .cam2 {
    width: 50%;
    height: 100%;
  }

  /* Right Section: Status and Control */
  .right-section {
    width: 30%;
    height: 100%;
    padding: 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  /* Status Box Styling */
  .status-box {
    flex: 1;
    background: #000;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-wrap: wrap;
    overflow: hidden;
  }
  .status-box .part {
    width: 50%;
    height: 50%;
    box-sizing: border-box;
    padding: 4px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }
  .status-box .image-part img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: inherit;
  }

  /* Bar styling */
  .bar-container {
    width: 100%;
    margin: 5px 0;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .bar-label {
    color: #fff;
    font-size: 14px;
    width: 20px;
    text-align: center;
  }
  .bar {
    flex: 1;
    height: 20px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    position: relative;
    overflow: hidden;
  }
  .bar-fill {
    height: 100%;
    background-color: #ff6b00;
    border-radius: 10px;
    transition: width 0.3s ease;
  }
  .bar-value {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    color: #fff;
    font-size: 12px;
    font-weight: bold;
  }

  /* Control box with canvas and overlay */
  .control-box {
    flex: 1;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
  }
  #trackingCanvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  .status-overlay {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    z-index: 50;
  }

  /* Ensure camera-feed images fill their container or show black background */
  .camera-feed {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
    background-color: #000; /* Fallback color if image fails to load */
  }
</style>

<div class="container">
  <div class="camera-section">
    <div class="go-pro">
      <img
        src="{{ url_for('video_feed4') }}"
        alt="Camera 4"
        class="camera-feed"
      />
    </div>
    <div class="camera-feeds">
      <div class="zed">
        <img
          src="{{ url_for('video_feed4') }}"
          alt="Camera 4"
          class="camera-feed"
        />
      </div>
      <div class="cameras">
        <div class="cam1">
          <img
            src="{{ url_for('video_feed4') }}"
            alt="Camera 4"
            class="camera-feed"
          />
        </div>
        <div class="cam2">
          <img
            src="{{ url_for('video_feed4') }}"
            alt="Camera 4"
            class="camera-feed"
          />
        </div>
      </div>
    </div>
  </div>

  <!-- Right Section: Status and Control -->
  <div class="right-section">
    <!-- Status Box -->
    <div class="status-box">
      <!-- Top-left: Xview stream -->
      <div class="part">
        <img src="/xview_stream" alt="Xview" class="camera-feed" />
      </div>
      <!-- Top-right: Bars for X, Y, Z -->
      <div class="part">
        <div class="bar-container">
          <span class="bar-label">X</span>
          <div class="bar" id="bar-x">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
        <div class="bar-container">
          <span class="bar-label">Y</span>
          <div class="bar" id="bar-y">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
        <div class="bar-container">
          <span class="bar-label">Z</span>
          <div class="bar" id="bar-z">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
      </div>
      <!-- Bottom-left: Yview stream -->
      <div class="part image-part">
        <img src="/yview_stream" alt="Yview" class="camera-feed" />
      </div>
      <!-- Bottom-right: Zview stream -->
      <div class="part image-part">
        <img src="/zview_stream" alt="Zview" class="camera-feed" />
      </div>
    </div>

    <!-- Control Box with Canvas and Overlay -->
    <div class="control-box">
      <canvas id="trackingCanvas"></canvas>
      <div class="status-overlay">
        <div>X: <span id="xPos">0</span></div>
        <div>Y: <span id="yPos">0</span></div>
        <div>Heading: <span id="heading">0</span>Â°</div>
      </div>
    </div>
  </div>
</div>

<script>
  // Update Bars: Random value between 60 and 80 (simulate acceleration)
  function updateBar(barId) {
    const bar = document.getElementById(barId);
    const fill = bar.querySelector(".bar-fill");
    const valueLabel = bar.querySelector(".bar-value");
    const value = 60 + Math.floor(Math.random() * 21);
    fill.style.width = value + "%";
    valueLabel.textContent = value + "%";
  }

  function updateBars() {
    updateBar("bar-x");
    updateBar("bar-y");
    updateBar("bar-z");
  }

  setInterval(updateBars, 1000);
  updateBars();

  // Compass update
  async function updateCompass() {
    try {
      const response = await fetch("/compass-value");
      const data = await response.json();
      const angle = parseFloat(data.angle);
      document.getElementById(
        "compass"
      ).style.transform = `rotate(${angle}deg)`;
    } catch (error) {
      console.error("Error fetching compass value:", error);
    }
  }
  setInterval(updateCompass, 1000);
  updateCompass();

  // Rover Path Drawing on Canvas
  const controlBox = document.querySelector(".control-box");
  const canvas = document.getElementById("trackingCanvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = controlBox.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  let pathPoints = [];
  let pathSegments = [];

  function drawRover(x, y, heading) {
    const size = 8;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((heading * Math.PI) / 180);
    ctx.beginPath();
    ctx.moveTo(size, 0);
    ctx.lineTo(-size, -size);
    ctx.lineTo(-size, size);
    ctx.closePath();
    ctx.fillStyle = "#0066ff";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
    ctx.fillStyle = "#003d99";
    ctx.fill();
    ctx.restore();
  }

  function drawPath() {
    for (const segment of pathSegments) {
      if (segment.length < 2) continue;
      const gradient = ctx.createLinearGradient(
        0,
        0,
        canvas.width,
        canvas.height
      );
      gradient.addColorStop(0, "#ff6b00");
      gradient.addColorStop(1, "#ff3300");
      ctx.beginPath();
      ctx.moveTo(segment[0].x, segment[0].y);
      for (let i = 1; i < segment.length - 2; i++) {
        const xc = (segment[i].x + segment[i + 1].x) / 2;
        const yc = (segment[i].y + segment[i + 1].y) / 2;
        ctx.quadraticCurveTo(segment[i].x, segment[i].y, xc, yc);
      }
      if (segment.length > 2) {
        ctx.quadraticCurveTo(
          segment[segment.length - 2].x,
          segment[segment.length - 2].y,
          segment[segment.length - 1].x,
          segment[segment.length - 1].y
        );
      }
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    if (pathPoints.length < 2) return;
    const gradient = ctx.createLinearGradient(
      0,
      0,
      canvas.width,
      canvas.height
    );
    gradient.addColorStop(0, "#ff6b00");
    gradient.addColorStop(1, "#ff3300");
    ctx.beginPath();
    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
    for (let i = 1; i < pathPoints.length - 2; i++) {
      const xc = (pathPoints[i].x + pathPoints[i + 1].x) / 2;
      const yc = (pathPoints[i].y + pathPoints[i + 1].y) / 2;
      ctx.quadraticCurveTo(pathPoints[i].x, pathPoints[i].y, xc, yc);
    }
    if (pathPoints.length > 2) {
      ctx.quadraticCurveTo(
        pathPoints[pathPoints.length - 2].x,
        pathPoints[pathPoints.length - 2].y,
        pathPoints[pathPoints.length - 1].x,
        pathPoints[pathPoints.length - 1].y
      );
    }
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  function drawGrid() {
    const gridSize = 50;
    ctx.strokeStyle = "#e6e6e6";
    ctx.lineWidth = 0.5;
    for (let x = 0; x <= canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
  }

  async function updateRoverPosition() {
    try {
      const response = await fetch("/rover-position");
      const data = await response.json();
      const scaled = {
        x: (data.x / 800) * canvas.width,
        y: (data.y / 600) * canvas.height,
        heading: data.heading,
      };
      pathPoints.push(scaled);
      if (pathPoints.length > 100) {
        pathSegments.push([...pathPoints]);
        pathPoints = [pathPoints[pathPoints.length - 1]];
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawPath();
      drawRover(scaled.x, scaled.y, scaled.heading);
      document.getElementById("xPos").textContent = data.x.toFixed(1);
      document.getElementById("yPos").textContent = data.y.toFixed(1);
      document.getElementById("heading").textContent = data.heading.toFixed(1);
    } catch (error) {
      console.error("Error updating rover position:", error);
    }
  }
  setInterval(updateRoverPosition, 100);
</script>
{% endblock %}

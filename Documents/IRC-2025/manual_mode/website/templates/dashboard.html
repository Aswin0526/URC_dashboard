{% extends 'index.html' %} {% block content %}
<style>
  .container {
    display: flex;
    width: 100%;
    height: 90vh;
    background: #f0f0f0;
    position: relative;
    top: 2%;
  }

  .camera-section {
    width: 70%;
    height: 100%;
    display: flex;
    padding: 10px;
    gap: 10px;
  }

  .main-feed {
    width: 70%;
    height: 100%;
    background: #333;
    border-radius: 8px;
  }

  .side-feeds {
    width: 30%;
    height: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .camera-container {
    height: 33.33%;
    background: #333;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
  }

  .camera-container:hover {
    opacity: 0.8;
  }

  .right-section {
    width: 30%;
    height: 100%;
    padding: 10px;
  }

  .status-box {
    height: 50%;
    background: #000;
    margin-bottom: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-wrap: wrap;
  }

  .part {
    width: 50%;
    height: 50%;
    box-sizing: border-box;
    padding: 2px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .image-part img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: inherit;
  }

  /* Enhanced Bar Styling */
  .bar-container {
    width: 100%;
    margin: 15px 0;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }

  .bar-label {
    color: #fff;
    margin-bottom: 5px;
    font-size: 14px;
  }

  .bar {
    width: 80%;
    height: 20px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    position: relative;
    overflow: hidden;
  }

  .bar-fill {
    height: 100%;
    background-color: #ff6b00;
    border-radius: 10px;
    transition: width 0.3s ease;
  }

  .bar-value {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: #fff;
    font-size: 12px;
    font-weight: bold;
  }
  .control-box {
    height: 50%;
    background: #fff;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    position: relative;
  }

  .camera-feed {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
  }

  .camera-label {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
  }

  #compass {
    position: absolute;
    top: 40px;
    right: 40px;
    width: 150px;
    height: 120px;
    z-index: 100;
    transition: transform 0.5s ease;
  }

  canvas {
    background: white;
    width: 100%;
    height: 100%;
  }

  .status-overlay {
    position: absolute;
    top: 30px;
    right: 30px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: monospace;
  }
</style>

<div class="container">
  <div class="camera-section">
    <div class="main-feed" id="mainFeedContainer" style="position: relative">
      <img src="static/images/compass.png" alt="" id="compass" />
      <div class="camera-label">Camera 1</div>
      <img
        src="{{ url_for('video_feed1') }}"
        alt="Camera 1"
        class="camera-feed"
        data-camera="1"
      />
    </div>
    <div class="side-feeds">
      <div class="camera-container">
        <div class="camera-label">Camera 2</div>
        <img
          src="{{ url_for('video_feed2') }}"
          alt="Camera 2"
          class="camera-feed"
          data-camera="2"
        />
      </div>
      <div class="camera-container">
        <div class="camera-label">Camera 3</div>
        <img
          src="{{ url_for('video_feed3') }}"
          alt="Camera 3"
          class="camera-feed"
          data-camera="3"
        />
      </div>
      <div class="camera-container">
        <div class="camera-label">Camera 4</div>
        <img
          src="{{ url_for('video_feed4') }}"
          alt="Camera 4"
          class="camera-feed"
          data-camera="4"
        />
      </div>
    </div>
  </div>
  <div class="right-section">
    <div class="status-box">
      <div class="part">
        <img src="/xview_stream" alt="Image 1" />
      </div>

      <div class="part">
        <div class="bar-container">
          <h2 style="color: white">X</h2>
          <div class="bar" id="bar-x">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
        <div class="bar-container">
          <h2 style="color: white">Y</h2>
          <div class="bar" id="bar-y">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
        <div class="bar-container">
          <h2 style="color: white">Z</h2>
          <div class="bar" id="bar-z">
            <div class="bar-fill"></div>
            <div class="bar-value">0%</div>
          </div>
        </div>
      </div>

      <div class="part image-part">
        <img src="/yview_stream" alt="Image 1" />
      </div>

      <div class="part image-part">
        <img src="/zview_stream" alt="Image 2" />
      </div>
    </div>

    <div class="control-box">
      <canvas id="trackingCanvas"></canvas>
      <div class="status-overlay">
        <div>X: <span id="xPos">0</span></div>
        <div>Y: <span id="yPos">0</span></div>
        <div>Heading: <span id="heading">0</span>Â°</div>
      </div>
    </div>
  </div>
</div>

<script>
  // Initialize camera positions tracking
  const cameraPositions = {
    main: 1, // Camera 1 starts in main position
    side1: 2, // Camera 2 starts in first side position
    side2: 3, // Camera 3 starts in second side position
    side3: 4, // Camera 4 starts in third side position
  };

  // Add click listeners to all cameras
  document.querySelectorAll(".camera-feed").forEach((camera) => {
    camera.parentElement.addEventListener("click", function () {
      const clickedCameraNumber = parseInt(camera.getAttribute("data-camera"));
      switchCamera(clickedCameraNumber);
    });
  });

  function switchCamera(clickedCameraNumber) {
    // Find the position of the clicked camera
    let clickedPosition = null;
    for (const [position, cameraNum] of Object.entries(cameraPositions)) {
      if (cameraNum === clickedCameraNumber) {
        clickedPosition = position;
        break;
      }
    }

    if (clickedPosition && clickedPosition !== "main") {
      // Get the main camera number
      const mainCameraNumber = cameraPositions.main;

      // Get the camera elements
      const mainCamera = document.querySelector("#mainFeedContainer img");
      const clickedCamera = document.querySelector(
        `[data-camera="${clickedCameraNumber}"]`
      );

      // Swap sources and data attributes
      const mainSrc = mainCamera.src;
      mainCamera.src = clickedCamera.src;
      clickedCamera.src = mainSrc;

      // Update data-camera attributes
      mainCamera.setAttribute("data-camera", clickedCameraNumber);
      clickedCamera.setAttribute("data-camera", mainCameraNumber);

      // Update labels
      document.querySelector(
        "#mainFeedContainer .camera-label"
      ).textContent = `Camera ${clickedCameraNumber}`;
      clickedCamera.parentElement.querySelector(
        ".camera-label"
      ).textContent = `Camera ${mainCameraNumber}`;

      // Update positions tracking
      cameraPositions[clickedPosition] = mainCameraNumber;
      cameraPositions.main = clickedCameraNumber;
    }
  }

  function updateBar(barId) {
    const bar = document.getElementById(barId);
    const fill = bar.querySelector(".bar-fill");
    const valueLabel = bar.querySelector(".bar-value");
    // Generate a random value between 0 and 100 (simulate acceleration)
    const value = 60 + Math.floor(Math.random() * 21);
    fill.style.width = value + "%";
    valueLabel.textContent = value + "%";
  }

  // Function to update all three bars
  function updateBars() {
    updateBar("bar-x");
    updateBar("bar-y");
    updateBar("bar-z");
  }

  // Update the bars every second
  setInterval(updateBars, 1000);
  // Initial update
  updateBars();

  // compass

  async function updateCompass() {
    try {
      const response = await fetch("/compass-value");
      const data = await response.json();
      const angle = parseFloat(data.angle);
      // Update the compass image rotation via CSS transform
      const compass = document.getElementById("compass");
      compass.style.transform = `rotate(${angle}deg)`;
    } catch (error) {
      console.error("Error fetching compass value:", error);
    }
  }

  // Update the compass value every second
  setInterval(updateCompass, 1000);

  // Initial update on page load.
  updateCompass();

  // roverpath
  // Get the control box dimensions
  const controlBox = document.querySelector(".control-box");
  const canvas = document.getElementById("trackingCanvas");
  const ctx = canvas.getContext("2d");

  // Set canvas dimensions to match control box
  function resizeCanvas() {
    const boxRect = controlBox.getBoundingClientRect();
    canvas.width = boxRect.width;
    canvas.height = boxRect.height;
  }

  // Initial resize
  resizeCanvas();

  // Handle window resize
  window.addEventListener("resize", resizeCanvas);

  let pathPoints = [];
  let pathSegments = []; // Store multiple path segments

  function drawRover(x, y, heading) {
    const size = 8;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate((heading * Math.PI) / 180);

    // Draw triangle
    ctx.beginPath();
    ctx.moveTo(size, 0);
    ctx.lineTo(-size, -size);
    ctx.lineTo(-size, size);
    ctx.closePath();
    ctx.fillStyle = "#0066ff";
    ctx.fill();

    // Draw circle at base
    ctx.beginPath();
    ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
    ctx.fillStyle = "#003d99";
    ctx.fill();

    ctx.restore();
  }

  function drawPath() {
    // Draw all path segments
    for (const segment of pathSegments) {
      if (segment.length < 2) continue;

      const gradient = ctx.createLinearGradient(
        0,
        0,
        canvas.width,
        canvas.height
      );
      gradient.addColorStop(0, "#ff6b00");
      gradient.addColorStop(1, "#ff3300");

      ctx.beginPath();
      ctx.moveTo(segment[0].x, segment[0].y);

      // Draw curved path through points
      for (let i = 1; i < segment.length - 2; i++) {
        const xc = (segment[i].x + segment[i + 1].x) / 2;
        const yc = (segment[i].y + segment[i + 1].y) / 2;
        ctx.quadraticCurveTo(segment[i].x, segment[i].y, xc, yc);
      }

      // Handle last two points
      if (segment.length > 2) {
        ctx.quadraticCurveTo(
          segment[segment.length - 2].x,
          segment[segment.length - 2].y,
          segment[segment.length - 1].x,
          segment[segment.length - 1].y
        );
      }

      ctx.strokeStyle = gradient;
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Draw current path segment
    if (pathPoints.length < 2) return;

    const gradient = ctx.createLinearGradient(
      0,
      0,
      canvas.width,
      canvas.height
    );
    gradient.addColorStop(0, "#ff6b00");
    gradient.addColorStop(1, "#ff3300");

    ctx.beginPath();
    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);

    for (let i = 1; i < pathPoints.length - 2; i++) {
      const xc = (pathPoints[i].x + pathPoints[i + 1].x) / 2;
      const yc = (pathPoints[i].y + pathPoints[i + 1].y) / 2;
      ctx.quadraticCurveTo(pathPoints[i].x, pathPoints[i].y, xc, yc);
    }

    if (pathPoints.length > 2) {
      ctx.quadraticCurveTo(
        pathPoints[pathPoints.length - 2].x,
        pathPoints[pathPoints.length - 2].y,
        pathPoints[pathPoints.length - 1].x,
        pathPoints[pathPoints.length - 1].y
      );
    }

    ctx.strokeStyle = gradient;
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  function drawGrid() {
    const gridSize = 50;
    ctx.strokeStyle = "#e6e6e6";
    ctx.lineWidth = 0.5;

    for (let x = 0; x <= canvas.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    for (let y = 0; y <= canvas.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
  }

  async function updateRoverPosition() {
    try {
      const response = await fetch("/rover-position");
      const data = await response.json();

      const scaledData = {
        x: (data.x / 800) * canvas.width,
        y: (data.y / 600) * canvas.height,
        heading: data.heading,
      };

      pathPoints.push(scaledData);

      // If path gets too long, store it as a segment and start a new path
      if (pathPoints.length > 100) {
        pathSegments.push([...pathPoints]);
        pathPoints = [pathPoints[pathPoints.length - 1]]; // Start new path from last point
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background elements
      drawGrid();

      // Draw all paths
      drawPath();
      drawRover(scaledData.x, scaledData.y, scaledData.heading);

      // Update status overlay
      document.getElementById("xPos").textContent = data.x.toFixed(1);
      document.getElementById("yPos").textContent = data.y.toFixed(1);
      document.getElementById("heading").textContent = data.heading.toFixed(1);
    } catch (error) {
      console.error("Error updating rover position:", error);
    }
  }

  // Update position every 100ms for smooth animation
  setInterval(updateRoverPosition, 100);
</script>
{% endblock %}
